module motherboard (
    input clk,  // clock
    input rst,  // reset
    input irq[3],
    input slowclk, 
    output id[32],
    output ia[32],
    output ma[32],  // ALU output / EA
    output mrd[32], // Mem[EA]
    output mwd[32], // RD2 output 
    output outputBuffer[32],
    output inputBuffer[32],
    output debug[4][16]
) {
    
    // Beta CPU
    betaCpu beta(.clk(clk))
    
    // setup and instantiate memory unit and instruction ROM
    const MEMORY_SIZE = 32
    instructionRom instructionUnit(#WORDS(MEMORY_SIZE))
    memoryUnit memoryUnit(#WORDS(MEMORY_SIZE), .clk(clk)) 
    
    // prepare output buffer
    dff systemOutputBuffer[32](.clk(clk), .rst(rst)) // 32 bit beta output buffer, hardwired to always read memoryUnit value at byte address 0xC
    // prepare input buffer
    dff systemInputBuffer[32](.clk(clk), .rst(rst)) // 32 bit beta input buffer, hardwired to always write memoryUnit value at byte address 0x10
    
    // counter to write instructions from ROM to instruction memory
    dff writerCounter[$clog2(MEMORY_SIZE)](.clk(clk))
    enum MotherboardStates {INSTRUCTIONLOAD, RUN, LOAD_OUTPUT, DISPLAY_OUTPUT, UPDATE_INPUT}
    dff motherboard[$width(MotherboardStates)](.clk(clk), .rst(rst), #INIT(MotherboardStates.INSTRUCTIONLOAD))
    
    always {
        instructionUnit.addr = 0 // always set to 0 initially
        beta.irq = |irq // IRQ as long as any of of the buttons[2:0] is pressed
        
        // store the button press to input buffer 
        if (|irq){
            if (irq[0]){
                systemInputBuffer.d = 32hB0
            }
            else if (irq[1]){
                systemInputBuffer.d = 32hB1
            }
            else if (irq[2]){
                systemInputBuffer.d = 32hB2
            }
        }
        
        beta.slowclk = slowclk 
        beta.rst = rst
        
        // connect memory unit with beta 
        beta.instruction = memoryUnit.id
        beta.memDataInput = memoryUnit.mrd
        memoryUnit.ia = beta.ia[31:0] 
        memoryUnit.wd = beta.memDataOutput 
        memoryUnit.we = beta.wr 
        memoryUnit.waddr = beta.memDataAddress[31:0] 
        memoryUnit.raddr = beta.memDataAddress[31:0] 
        
        // turn off instruction loading
        memoryUnit.instructionWE = b0
        memoryUnit.instructionWD = 32b0 
        
        // Load ROM instructions to RAM first, then run the Beta 
        case(motherboard.q){
            // instruction loading
            MotherboardStates.INSTRUCTIONLOAD:
                beta.rst = 1
                writerCounter.d = writerCounter.q + 1
                instructionUnit.addr = writerCounter.q
                memoryUnit.instructionWD = instructionUnit.out
                memoryUnit.instructionWE = b1
                memoryUnit.ia = writerCounter.q<<2 // pad with two zeroes to make it byte addressable because memoryUnit expects byte addresing ia
                if ((writerCounter.q + 1) == MEMORY_SIZE){
                    motherboard.d = MotherboardStates.RUN // wait one more clock cycle to allow the last instruction to be loaded before start execution
                }
            
            MotherboardStates.RUN:
                // only load output and update input at the the beginning of each "next" instruction cycle 
                // LOAD_OUTPUT will hijack EA for 2 clk cycles. At this point, the CPU is not receiving a legitimate Mem[EA] if it is doing a LD/LDR 
                // However since "slowclk" is more than 2 clk cycles, it will be fixed by the third cycle 
                // actual EA coming out from beta is valid by then, when plugged into memory unit
                if (slowclk){
                    motherboard.d = MotherboardStates.LOAD_OUTPUT
                }
                else{
                    motherboard.d = MotherboardStates.RUN
                }
            
            MotherboardStates.LOAD_OUTPUT:
                // load hardcoded byte address 32hC (12) for output 
                memoryUnit.raddr = 32hC
                motherboard.d = MotherboardStates.DISPLAY_OUTPUT
            
            MotherboardStates.DISPLAY_OUTPUT:
                // display Mem[12] to beta_output_buffer for user to see
                systemOutputBuffer.d = memoryUnit.mrd // Note: a little bit janky in simulation, will sometimes overwrite 
                motherboard.d = MotherboardStates.UPDATE_INPUT
            
            MotherboardStates.UPDATE_INPUT:
                // always store hardcoded byte address 32h10 (16) for any incoming input each time "next" happens
                // need 2x original clock cycles for data to be readable at 32h10, plenty of time since "next" is more than 2 cycles
                memoryUnit.waddr = 32h10
                memoryUnit.wd = systemInputBuffer.q
                memoryUnit.we = 1
                motherboard.d = MotherboardStates.RUN
        }
        
        // output values
        outputBuffer = systemOutputBuffer.q
        inputBuffer = systemInputBuffer.q
        ia = beta.ia
        id = memoryUnit.id
        ma = beta.memDataAddress
        mrd = memoryUnit.mrd
        mwd = beta.memDataOutput
        debug = beta.debug
        
    }
}