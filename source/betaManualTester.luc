module betaManualTester#(
    CLK_FREQ ~ 1000 : CLK_FREQ > 0)  
(
    input clk,              // 100MHz clock
    input rst,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    output ioLed [3][8],   // LEDs on IO Shield
    output ioSeg [8],      // 7-segment LEDs on IO Shield
    output ioSel [4],      // Digit select on IO Shield
    input ioButton [5],    // 5 buttons on IO Shield
    input ioDip [3][8]     // DIP switches on IO Shield
) {
    
    // helper signals
    sig next                 // next instruction signal
    sig debugPcsel[16]
    sig debugAsel[16]
    sig debugBsel[16]
    sig debugWdsel[16]
    
    // motherboard
    motherboard motherboard(.clk(clk), .rst(rst))
    
    // manual next button to advance one instruction
    dff next_button(.clk(clk)) // TODO: check if we need this in hardware?
    // NOTE: CHECKED, works normally in hardware 
    // without dff works fine too in hardware
    // in simulation with 1000Hz clock, this causes 2 PC advance when next button is clicked
    // using automatic next with fastclock it's fine
    // perhaps it's because the clk is not stable, not always 1000Hz
    
    buttonConditioner next_button_conditioner(#CLK_FREQ(CLK_FREQ), .clk(clk))
    edgeDetector next_button_edge(#RISE(1), #FALL(0), .clk(clk))
    
    // interrupt button conditioners, edge detector, and input buffer
    buttonConditioner interrupt_button_conditioner[3](.clk(3x{clk}), #CLK_FREQ(3x{{CLK_FREQ}})) 
    edgeDetector interrupt_button_edge[3](#RISE(3x{{1}}), #FALL(3x{{0}}), .clk(3x{clk}))
    
    // to run beta at slower clock than FPGA clock
    counter frequency_divider(#SIZE(28), .clk(clk), .rst(rst))
    edgeDetector slowclock_edge(#RISE(1), #FALL(0), .clk(clk))
    edgeDetector fastclock_edge(#RISE(1), #FALL(0), .clk(clk)) 
    
    // OTHERS (for debug)
    multiSevenSeg seg(.clk(clk),.rst(rst), #DIV($isSim() ? 5 : 16)) // put div 5 for sim
    
    always {
        ioLed = 3x{{h00}}       // turn all LED off at first
        ioSeg = 8hff // connect segments to the driver
        ioSel = 4hf // connect digit select to the driver
        
        
        led = c{3b0, ioButton}  // connect buttons to LEDs
        
        ioLed[2][7] = ioDip[2][7] // see toggle manual/auto mode
        ioLed[2][6] = ioDip[2][6] // see toggle fastclock 
        ioLed[2][5] = frequency_divider.value[27] 
        ioLed[2][4] = frequency_divider.value[8]  
        
        // next button
        next_button_conditioner.in = ioButton[4]
        next_button_edge.in = next_button_conditioner.out
        
        // TODO: to check with hardware
        // do we need to store it like this in a dff? this will delay advancement by 1 clk cycle
        next_button.d = next_button_edge.out 
        
        // driving the beta 
        slowclock_edge.in = frequency_divider.value[27]
        fastclock_edge.in = frequency_divider.value[8] // for simulation, because we work with 1000Hz clock
        
        // connect hardware interrupt button 
        interrupt_button_conditioner.in = ioButton[2:0]
        interrupt_button_edge.in = interrupt_button_conditioner.out
        motherboard.irq = interrupt_button_edge.out // IRQ as long as any of of the buttons[2:0] is pressed
        
        // NOTE
        // Checked with hardware: no issue using the dff
        // bug with the simulation, will trigger 2x
        // next =  (slowclock_edge.out & ioDip[2][7]) | next_button.q; 
        next = (slowclock_edge.out & ioDip[2][7]) | next_button_edge.out // proceed either when next button is pressed or io_dip[2][7] is 1
        
        
        if (ioDip[2][6]){ // want faster clock
            // NOTE
            // Checked with hardware: no issue using the dff
            // next = (fastclock_edge.out & ioDip[2][7]) | next_button.q; // proceed either when next button is pressed or io_dip[2][7] is 1
            next = (fastclock_edge.out & ioDip[2][7]) | next_button_edge.out
        }
        
        
        motherboard.slowclk = next
        
        // debugger to view Beta state    
        seg.values = {4b0,4b0,4b0,4b0}
        ioSeg = ~seg.seg
        ioSel = ~seg.sel
        
        debugPcsel = motherboard.debug[0]
        debugAsel = motherboard.debug[1]
        debugBsel = motherboard.debug[2]
        debugWdsel = motherboard.debug[3]
        
        case (ioDip[0]){
            h00: // MSB 16 bits of current instruction (id[31:16])
                ioLed[0] = motherboard.id[23:16]
                ioLed[1] = motherboard.id[31:24]
                seg.values = {motherboard.id[31:28], motherboard.id[27:24], motherboard.id[23:20], motherboard.id[19:16]}
            h01: // LSB 16 bits of current instruction (id[15:0])
                ioLed[0] = motherboard.id[7:0]
                ioLed[1] = motherboard.id[15:8]
                seg.values = {motherboard.id[15:12], motherboard.id[11:8], motherboard.id[7:4], motherboard.id[3:0]} 
            h02: // LSB 16 bits of instruction address (ia[15:0])
                ioLed[0] = motherboard.ia[7:0]
                ioLed[1] = motherboard.ia[15:8]
                seg.values = {motherboard.ia[15:12], motherboard.ia[11:8], motherboard.ia[7:4], motherboard.ia[3:0]}
            h03: // LSB 16 bits of EA (this is also ALU output) (ma[15:0])
                ioLed[0] = motherboard.ma[7:0]
                ioLed[1] = motherboard.ma[15:8]
                seg.values = {motherboard.ma[15:12], motherboard.ma[11:8],motherboard.ma[7:4], motherboard.ma[3:0]}
            h04: // MSB 16 bits of EA (this is also ALU output) (ma[31:16])
                ioLed[0] = motherboard.ma[23:16]
                ioLed[1] = motherboard.ma[31:24]
                seg.values = {motherboard.ma[31:28], motherboard.ma[27:24], motherboard.ma[23:20], motherboard.ma[19:16]} 
            h05: // LSB 16 bits of Mem[EA] (mrd[15:0])
                ioLed[0] = motherboard.mrd[7:0]
                ioLed[1] = motherboard.mrd[15:8]
                seg.values = {motherboard.mrd[15:12], motherboard.mrd[11:8], motherboard.mrd[7:4], motherboard.mrd[3:0]} 
            h06: // MSB 16 bits of Mem[EA] (mrd[31:16])
                ioLed[0] = motherboard.mrd[23:16]
                ioLed[1] = motherboard.mrd[31:24]
                seg.values = {motherboard.mrd[31:28], motherboard.mrd[27:24], motherboard.mrd[23:20], motherboard.mrd[19:16]} 
            h07: // LSB 16 bits of RD2 (mwd[15:0]) 
                ioLed[0] = motherboard.mwd[7:0]
                ioLed[1] = motherboard.mwd[15:8]
                seg.values = {motherboard.mwd[15:12], motherboard.mwd[11:8],motherboard.mwd[7:4], motherboard.mwd[3:0]}
            h08: // MSB 16 bits of RD2 (mwd[31:16])
                ioLed[0] = motherboard.mwd[23:16]
                ioLed[1] = motherboard.mwd[31:24]
                seg.values = {motherboard.mwd[31:28], motherboard.mwd[27:24], motherboard.mwd[23:20], motherboard.mwd[19:16]}
            h09: // LSB 16 bits of pcsel_out
                ioLed[0] = debugPcsel[7:0]
                ioLed[1] = debugPcsel[15:8]
                seg.values = {debugPcsel[15:12], debugPcsel[11:8], debugPcsel[7:4], debugPcsel[3:0]}
            h0A: // LSB 16 bits of asel_out
                ioLed[0] = debugAsel[7:0]
                ioLed[1] = debugAsel[15:8]
                seg.values = {debugAsel[15:12], debugAsel[11:8], debugAsel[7:4], debugAsel[3:0]}
            h0B: // LSB 16 bits of bsel_out
                ioLed[0] = debugBsel[7:0]
                ioLed[1] = debugBsel[15:8]
                seg.values = {debugBsel[15:12], debugBsel[11:8], debugBsel[7:4], debugBsel[3:0]}
            h0C: // LSB 16 bits of wdsel_out
                ioLed[0] = debugWdsel[7:0]
                ioLed[1] = debugWdsel[15:8]
                seg.values = {debugWdsel[15:12], debugWdsel[11:8], debugWdsel[7:4], debugWdsel[3:0]}
            h0D: // MSB 16 bits of instruction address. Useful to see PC31 (kernel/user mode) (ia[31:16])
                ioLed[0] = motherboard.ia[31:24]
                ioLed[1] = motherboard.ia[23:16]
                seg.values = {motherboard.ia[31:28], motherboard.ia[27:24], motherboard.ia[23:20], motherboard.ia[19:16]} 
            h0E: // LSB 16 bits of system_input_buffer 
                ioLed[1:0] = {motherboard.inputBuffer[15:8], motherboard.inputBuffer[7:0]}
                seg.values = {motherboard.inputBuffer[15:12], motherboard.inputBuffer[11:8], motherboard.inputBuffer[7:4], motherboard.inputBuffer[3:0]} 
            h0F: // LSB 16 bits of system_output_buffer 
                ioLed[1:0] = {motherboard.outputBuffer[15:8], motherboard.outputBuffer[7:0]}
                seg.values = {motherboard.outputBuffer[15:12], motherboard.outputBuffer[11:8], motherboard.outputBuffer[7:4],motherboard.outputBuffer[3:0]} 
        }
    }
}